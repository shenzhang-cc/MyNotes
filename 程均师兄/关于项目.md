# Web_Server

## 1. 项目目的

团队在发展的同时需要向外宣传自己，为了更好地宣传自己的团队，所以我萌发了开发一个服务器后端及网页端，让更多的同学来了解我们的团队文化及建设。

## 2. 遇到困难

1. 在编译时候遇到错误 undefined reference to ...   网上搜了一下得到的答案是某一部分的.o文件没有链接上，于是我把cMakeLists.txt重新看了一遍，然后又到错误的地方看了一遍，没有找出问题。  后来发现我定义了两个名字差不多的变量  一个mime，另外一个是mine，然后在项目中交叉使用了这两个名字导致编译错误。     实际上.h文件中类中声明的静态变量，如果需要在同名cpp文件中使用，那么需要在文件头声明。
2. 在运行时候一直遇到“设置非阻塞模式失败”，检查了许久的代码，没发现问题，后来发现是把端口号写错了。
3. 如何设计各个线程任务
4. 在编译完成以后，遇到了Bad file descriptor 错误。ulimit -a查看core文件是否开启，（ulimit -c unlimited）开启生成core文件    对core文件进行调试   gdb server  core。  发现 `_GI_ abort()` 错误                然后通过gdb单步调试，调试到出问题的地方，打断点再反复调试，发现有个参数是sizeof()，我写成了size_t



## 3. 项目结构

### 并发模型

程序使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。

**Reactor模型：**（是什么？）1. 事件驱动 2. 可以处理一个或者多个输入源 3. 通过service Handler同步的将输入事件(Event)采用多路复用分发给想用的Request Handler(多个)处理         

​                           （为什么用？）常见的网络服务中，如果每一个客户端都维持一个与登录服务器的连接，那么服务器将维护多个和客户端的连接 以出来和客户端的connect、read、write，特别是长连接的服务，有多个client，就需要在server端维护同等的IO连接，这对服务器来说，是非常大的开销。

![model.png](https://github.com/linyacool/WebServer/blob/master/datum/model.png?raw=true)



MainReactor只有一个，负责响应client的连接请求，并建立连接，它使用一个NIO Selector。在建立连接后用Round Robin（**轮循调度**）的方式分配给某个SubReactor,因为涉及到跨线程任务分配，需要加锁，这里的锁由某个特定线程中的loop创建，只会被该线程和主线程竞争。

SubReactor可以有一个或者多个，每个subReactor都会在一个独立线程中运行，并且维护一个独立的NIO Selector。

当主线程把新连接分配给了某个SubReactor，该线程此时可能正阻塞在多路选择器(epoll)的等待中，怎么得知新连接的到来呢？这里使用了eventfd进行异步唤醒，线程会从epoll_wait中醒来，得到活跃事件，进行处理。

我学习了muduo库中的runInLoop和queueInLoop的设计方法，这两个方法主要用来执行用户的某个回调函数，queueInLoop是跨进程调用的精髓所在，具有极大的灵活性，我们只需要绑定好回调函数就可以了，我仿照muduo实现了这一点

### epoll触发模式

epoll的触发模式在这里我选择了ET模式，muduo使用的是LT，这两者IO处理上有很大的不同。ET模式要比LE复杂许多，它对用户提出了更高的要求，即每次读，必须读到不能再读(出现EAGAIN)，每次写，写到不能再写(出现EAGAIN)。而LT则简单的多，可以选择也这样做，也可以为编程方便，比如每次只read一次(muduo就是这样做的，这样可以减少系统调用次数)。

### 定时器

每个SubReactor持有一个定时器，用于处理超时请求和长时间不活跃的连接。muduo中介绍了时间轮的实现和用stl里set的实现，这里我的实现直接使用了stl里的priority_queue，(在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。其底层是用堆来实现的。在优先队列中，**队首元素一定是当前队列中优先级最高的那一个。**第三个参数( less )，则是一个比较类，**less 表示数字大的优先级高，而 greater 表示数字小的优先级高**。)   底层是小根堆，并采用惰性删除的方式，时间的到来不会唤醒线程，而是每次循环的最后进行检查，如果超时了再删，因为这里对超时的要求并不会很高，如果此时线程忙，那么检查时间队列的间隔也会短，如果不忙，也给了超时请求更长的等待时间。

优先队列的小根堆：因为优先队列队首指向最后，队尾指向最前面的缘故！每次入队元素进去经排序调整后，优先级最大的元素排在最前面，也就是队尾指向的位置，这时候队首指向优先级最小的元素！所以虽然使用less但其实相当于greater，我们重载运算符的时候比较函数里面写>就相当于<排序方式，

### 核心结构

程序中的每一个类和结构体当然都必不可少，其中能体现并发模型和整体架构的，我认为是有两个：

- Channel类：Channel是Reactor结构中的“事件”，它自始至终都属于一个EventLoop，负责一个文件描述符的IO事件，在Channel类中保存这IO事件的类型以及对应的回调函数，当IO事件发生时，最终会调用到Channel类中的回调函数。因此，程序中所有带有读写时间的对象都会和一个Channel关联，包括loop中的eventfd，listenfd，HttpData等。
- EventLoop：One loop per thread意味着每个线程只能有一个EventLoop对象，EventLoop即是时间循环，每次从poller里拿活跃事件，并给到Channel里分发处理。EventLoop中的loop函数会在最底层(Thread)中被真正调用，开始无限的循环，直到某一轮的检查到退出状态后从底层一层一层的退出。

### LOG

异步处理日志文件的核心就是使用另外一个写入线程，专门将需要记录的缓冲区块写入到磁盘中的日志文件中。

Log的实现了学习了muduo，Log的实现分为前端和后端，前端往后端写，后端往磁盘写。为什么要这样区分前端和后端呢？因为只要涉及到IO，无论是网络IO还是磁盘IO，肯定是慢的，慢就会影响其它操作，必须让它快才行。

这里的Log前端是前面所述的IO线程，负责产生log，后端是Log线程，设计了多个缓冲区，负责收集前端产生的log，集中往磁盘写。这样，Log写到后端是没有障碍的，把慢的动作交给后端去做好了。

后端主要是由多个缓冲区构成的，集满了或者时间到了就向文件写一次。采用了muduo介绍了“双缓冲区”的思想，实际采用4个多的缓冲区(为什么说多呢？为什么4个可能不够用啊，要有备无患)。4个缓冲区分两组，每组的两个一个主要的，另一个防止第一个写满了没地方写，写满或者时间到了就和另外两个交换**指针**，然后把满的往文件里写。

与Log相关的类包括FileUtil、LogFile、AsyncLogging、LogStream、Logging。 其中前4个类每一个类都含有一个append函数，Log的设计也是主要围绕这个**append**函数展开的。

- FileUtil是最底层的文件类，封装了Log文件的打开、写入并在类析构的时候关闭文件，底层使用了标准IO，该append函数直接向文件写。
- LogFile进一步封装了FileUtil，并设置了一个循环次数，每过这么多次就flush一次。
- AsyncLogging是核心，它负责启动一个log线程，专门用来将log写入LogFile，应用了“双缓冲技术”，其实有4个以上的缓冲区，但思想是一样的。AsyncLogging负责(定时到或被填满时)将缓冲区中的数据写入LogFile中。
- LogStream主要用来格式化输出，重载了<<运算符，同时也有自己的一块缓冲区，这里缓冲区的存在是为了缓存一行，把多个<<的结果连成一块。
- Logging是对外接口，Logging类内涵一个LogStream对象，主要是为了每次打log的时候在log之前和之后加上固定的格式化的信息，比如打log的行、文件名等信息。



## 4. 测试及改进



## 5. 连接维护(针对非阻塞IO)

### 建立连接

- 建立连接的过程
  连接的建立比较简单，server端通过socket()，bind()，listen()，并使用epoll ET模式监听listenfd的读请求，当TCP连接完成3次握手后，会触发listenfd的读事件，应用程序调用accept()，会检查已完成的连接队列，如果队列里有连接，就返回这个连接，出错或连接为空时返回-1。此时，已经可以进行正常的读写操作了。 当然，因为是ET模式，accept()要一直循环到就绪连接为空。
- 分析
  之所以说建立连接的过程比较简单，是因为数据的通信已经由操作系统帮我们完成了，这里的通信是指3次握手的过程，这个过程不需要应用程序参与，当应用程序感知到连接时，此时该连接已经完成了3次握手的过程，accept就好了。另一个原因是一般情况下，连接的建立都是client发起的，server端被动建立连接就好了，也不会出现同时建立的情况。
- 限制
  假设server只监听一个端口，一个连接就是一个四元组(原ip，原port，对端ip, 对端port)，那么理论上可以建立2^48个连接，可是，fd可没有这么多(操作系统限制、用户进程限制)。当连接满了，如果空等而不连接，那么就绪队列也满了后，会导致新连接无法建立。这里的做法我参考了muduo，准备一个空的文件描述符，accept()后直接close()，这样对端不会收到RST，至少可以知道服务器正在运行。

### 关闭连接

相对于连接的建立，关闭连接则复杂的多，远不是一个close()那么简单，关闭连接要优雅。

#### 什么时候关闭连接？

通常server和client都可以主动发Fin来关闭连接

- 对于client(非Keep-Alive)，发送完请求后就可以shutdown()写端，然后收到server发来的应答，最后close掉连接。也可以不shutdown()写，等读完直接close。对于Keep-Alive的情况，就要看client的心情了，收到消息后可以断，也可以不断，server应该保证不主动断开。
- 对于server端，毫无疑问应该谨慎处理以上所有情况。具体说来:

> - 出现各种关于连接的错误时，可以直接close()掉
> - 短连接超时的请求，可以close()，也可以不关
> - 长连接对方长时间没有请求(如果没有保活机制)，可以close()，也可以不关
> - client发出Fin，server会收到0字节，通常不能判断client是close了还是shutdown，这时server应当把消息发完，然后才可以close()，如果对方调用的是close，会收到RST，server能感知到，就可以立即close了
> - 短连接正常结束，server可以close，也可以不close，大多数的实现是不close的(对HTTP1.1而言)

#### EPOLLIN触发但是read()返回0的情况

这种情况通常有两个原因:

> - 对端已经关闭了连接，这时再写该fd会出错，此时应该关闭连接
> - 对端只是shutdown()了写端，告诉server我已经写完了，但是还可以接收信息。server应该在写完所有的信息后再关闭连接。更优雅的做法是透明的传递这个行为，即server顺着关闭读端，然后发完数据后关闭。



## 6. 项目面试问题

- 介绍一下这个项目(几乎是必问的)

- 定时器是怎么实现的？还有什么实现方式？

- 实现一个无锁队列(用原子操作)

- eventfd是什么？有什么好处？

- 双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？

- 什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())

- epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)

- epoll为什么高效，相比select和poll

- HTTP报文都有哪些字段？

- 假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)            (Nginx的进程分为master主进程和work工作进程，master进程主要管理事件信号接受和分发，所有的请求处理都由work进程处理并返回结 果，Nginx的平滑重启或重载配置文件等升级，首先是向master发送重启或重载配置文件信号，然后master告诉所有的work进程不再接受新的 请求，然后master另起新的work进程，最后告诉旧的work进程可以光荣退出了。                 

  在upgrade过程中，还涉及到3个信号（USR2、WINCH和QUIT）。
  首先发送USR2信号给原master，原master进程会额外启动一个master进程和若干worker进程，新旧worker进程同时提供对外服务。
  第二步发送WINCH信号，原worker进程停止服务并退出。
  最后发送QUIT信号给原master使之退出，只保留新的master和worker。)

- 有没有实现内存池？

- 一个请求到来具体的处理过程是怎样的？

- 线程的唤醒还有哪些方式？wait()  notify()  notifyAll()

- 怎么检查内存泄漏的？

- 用到了哪些智能指针和RAII机制，几种锁的区别是什么

- 任务队列是怎么实现的，除了加锁还有什么方式？

- 如何解决死锁？

- 怎么进行压测的？

- 为什么要用非阻塞IO？(假设socket的读缓冲区已经有足够多的数据，需要调用三次read才能读取完毕。那么非阻塞IO的处理方式为循环的read，直到读完所有数据(EWOULDBLOCK异常)；           而阻塞IO的处理方式为每次只能调用一次read，因为多路复用只会告诉fd可读，但不会告诉有多少数据可读，所以你调用一次之后无法知道下一次是否会发生**阻塞现象**，所以只能等第二次循环，然后循环第三次。    而且后面这几种情况，必须采用非阻塞IO，**1.** 在ET模式下 ，ET模式指的是当数据从无到有时，才通知该fd。数据读不完，也不会再次通知，所以read时一定要采用循环的方式一直读到read函数返回-1为止。此时采用阻塞的read，那么就阻塞了整个线程。     **2.**某个socket接收缓冲区有新数据分节到达，然后select报告这个socket描述符可读，但随后，协议栈检查到这个新分节检验和错误，然后丢弃这个分节，这时候调用read则无数据可读，如果socket没有被设置nonblocking，此read将阻塞当前线程。可以看出，select返回某个描述符读写就绪，并不意味着接下来的读写操作全过程就一定不会阻塞。**所以I/O多路复用绝大部分时候是和非阻塞的socket联合使用。** )

- 为什么要做这个项目？

- Reactor模式是什么？



```c++
//httpdata
void handleRead()
{
    if (连接状态 == 正在断开)
    {
        
    }
    if (处理状态 == 解析URI)
    {
        if(再次解析) break；
        else if (解析错误)  break; //并报错
        else //让处理状态 = 解析头部
    }
    if (处理状态 == 解析头部)
    {
        if (再次解析) break;
        else if (解析错误) break;
        if (解析方法 = POST) //处理状态 = RECV_BODY
        else //处理状态 = 状态分析
    }
    if (处理状态 = RECV_BODY)
    {
        
    }
    if (处理状态 = STATE_ANALYSIS)
    {
        if (ANALYSIS SUCCESS)
            处理状态 = FINISH
    }
    
    if (未发生错误)
    {
        if (outBuffer.size() > 0)
        {
            handleWrite();
        }
    }
    
}

void handleWrtie()
{
    if (没有发生错误 && 连接状态 == 已断开连接)
    {
        if (outBuffer_.size() > 0)
            events_ |= EPOLLOUT;
    }
}

void handleConn()
{
    seperateTimer();
    if (无错误发生 && 连接状态 = 已连接)
    {
        if (有事件)
        {
            设置失效时间
            if (keepAlive)
                设置保活时间
            
        }
    }
}

void parseURI()
{
    //先解析请求行
}
void parseHeaders()//解析请求头部
{
    
}
void analysisRequest()
{
    
}
```



```c++
//HTTP 请求报文格式
//------------------
//请求行    <请求方法 URL 协议版本/r/n （回车符换行符）>
//请求头部  <头部字段：值/r/n>
//空行
//请求体

POST /user HTTP/1.1/r/n      //请求行
Host: www.user.com
Content-Type: application/x-www-form-urlencoded
Connection: Keep-Alive
User-agent: Mozilla/5.0.      //以上是首部行
（此处必须有一空行）  //空行分割header和请求内容 
name=world   请求体
```

- **关于accept的理解：**accept其实是从内核维护的已连接队列中取出一个返回给调用者，和三次握手没有关系，如果已连接队列为空，则accept会阻塞到已连接队列不为空。accept可以在三次握手之前调用，也可以在之后调用。
- **如何在get请求后返回一个.jpg格式的图片？**需要把一个文件序列化，变成通信双方都能感知的字节流发过去，客户端收到后把字节流重新解析成图片文件。OpenCV就提供了转换的函数。
- **本服务程序管线化的实现：**没有专门的实现，整个收发流程天生支持。是客户端决定是否发起管线化请求，服务器天然支持管线化请求（基于长连接）    且http管线化：只有幂等的请求能够被管线化。所谓冥等，就是多次执行多资源的影响，和一次执行对资源的影响相同。就是不相互依赖。
- **定时器问题：**每次事件来的时候（不管什么事件），都会分离定时器和事件，其实就是把定时器给关了，没有更新，直接添加新的。
- **多线程和多进程使用场合：**

1. 必须使用单线程的场合：程序可能会fork()；限制程序的CPU占用率
2. 多线程的使用场景：提高响应速度，让IO和计算相互重叠， 降低latency
3. linux能同时启用多少个线程：对于32bit，一个进程4G，用户态3G，一个线程的默认栈大小是10M，差不多可以启动300个线程。
4. 多线程能提高并发度吗？如果是thread per connection ，那么并发量最多300，所以不能；如果是event loop per thread，至少比单线程强
5. 多线程可以降低响应时间吗：充分利用多核资源，设计合理，可以。
6. 线程池大小阻抗匹配原则：
7. 如何设计连接关闭协议？



### 日志库详解

**日志模块前端部分的调用时序为：Logger -> Impl -> LogStream -> opreator<<FixBuffer  -> output -> AsyncLogging:: append **

使用LOG宏时会创建一个匿名Logger对象（其中包含一个Impl类型的成员变量），并调用stream()函数得到一个LogStream对象的引用，而LogStream重载了<<操作符，可以将日志信息存入LogStream的buffer中。这样LOG_语句执行结束时，匿名Logger对象被销毁，在Logger的析构函数中，会在日志消息的末尾添加LOG_语句的位置信息（文件名和行号），最后调用g_output()函数将日志信息传输到后端，由后端日志线程将日志消息写入日志文件。

强调一下，这里将Logger设置为匿名对象是一个非常重要的技巧，因为匿名对象是一使用完就马上销毁，而对于栈上的具名对象则是先创建的后销毁。也就是说，如果使用具名对象，则后创建的Logger对象会先于先创建的Logger对象销毁，这就会使得日志内容反序（更准确的说是一个作用域中的日志反序）。使用匿名Logger对象的效果就是：LOG_*这行代码不仅仅包含日志内容，还会马上把日志输出（并不一定会立即写到日志文件中，具体原因见多线程异步日志部分）。

**__ FILE __ : 在源文件中插入当前源文件路径及文件名**

**__ LINE __ : 在源文件中插入当前源文件行号**

------









# 高性能TCP/IP服务器

## 1. 项目目的

通过实现造轮子来了解服务器的详细搭建过程，串接自己所学知识点

## 2. 遇到困难

1.  在Linux中，关闭客户端，然后server会终止进程     原因：果客户端断开socket链接, 服务器继续向一个关闭的socket 发送数据(send, write)的时候, 系统会默认对服务器进程发送一个SIGPIPE信号, 这个信号的默认动作就是终止当前服务器进程.

   所以为了解决客户端断开后导致服务器进程结束的问题, 使用如下方法忽略**SIGPIPE**信号.

   ```c++
   struct sigaction sa;
   sa.sa_handler = SIG_IGN;
   sigaction( SIGPIPE, &sa, 0 );
   ```

2. 在调试内存池的时候，发现两块内存池之间的间隔大小不一样，通过调试发现返回的是头的位置指针，而不是可用位置的指针。

## 3. 项目结构

### 并发模型

![1565183491953](C:\Users\M.CJ\AppData\Roaming\Typora\typora-user-images\1565183491953.png)

### 定时器

利用C++11自带std::chrono，high_resolution_clock达到1ns级别    time_since_epoch()  (用于获取当前时间点距离时间戳的时间长度)  作用：在任务执行过程中用于休眠 

```c++
std::this_thread::sleep_for;　//表示当前线程休眠一段时间，休眠期间不与其他线程竞争CPU，根据线程需求，等待若干时间
```



### 消息报头

利用struct结构封装消息的**长度**和**命令类型**。作为基类。然后让不通的消息类型结构体继承它。比如登录类型消息、登录结果类型消息、登出消息类型、登出结果消息类型等。

升级服务器端的协议格式成新的，会导致旧的客户端无法使用（所以struct格式的有缺陷）

 **TLV**（Type-Length-Value）格式。这种格式的协议，我们可以方便地增删和修改字段类型，程序解析时根据每个字段的 type 来得到字段的类型。 为了解决兼容性问题，我们可以通过在每个字段前面加一个 type 类型也解决，我们可以使用一个 char 类型来表示常用的类型。

### 任务基类

封装一个专属任务处理类，首先会检测线程是否运行，当线程启动以后，检测任务缓冲区是否有任务，如果有就处理，没有的话就休眠一小会 1毫秒。 LOG类构造以后，在构造函数中就会启动这个任务类，构建新的线程。

### LOG

使用单例模式生成单一LOG对象，向外暴露一个info接口，用于写具体的LOG提示语。 fprintf向磁盘中文件中写

### 	Buffer的设计

缓冲区的作用：①解决TCP粘包的问题；②解决TCP随意发送任意大小数据块的问题，通过封装可以减少发送的次数③接收的时候当处理怠速的时候，可以充当缓冲的区域。

解决TCP粘包的问题：在buffer数据块中首先判断缓冲区的数据长度是否大于消息头的数据长度，这时候就可以知道当前消息的长度，判断消息缓冲区的数据长度大于消息长度。

### 心跳检测的设计

指定客户端心跳检测死亡倒计时时长60s。以消息作为心跳检测，客户端socket每发一次消息就重置心跳时间。

### 关于统计服务端发送消息次数

定义一个抽象基类，里面包含客户端加入事件、客户端离开事件、客户端消息事件以及recv事件。

客户端加入事件：当有一个客户端加入时，客户端数量就+1；

客户端离开事件：当有一个客户端离开时，客户端数量就-1；

客户端消息事件：表示客户端发了多少个消息，比如每个100K，有5个。

recv事件：接收一次数据行为

计算并输出每秒收到的网络消息：接收到的消息数量除以时间（因为时间不是绝对的精确到1s），计算以后会将消息数量归零。

使用阻塞IO



### 主要的设计流程

创建ser_socket，绑定IP地址和端口，启用监听，accept等待客户端的连接。将连接的客户端分为客户端数量最小的cellServer（其数量是按线程数量来定量的，即把客户端socket分给客户端数量最少的线程）。每个cellServer都带有一个客户端缓冲区，处理网络消息时需要从客户端缓冲区中取出客户数据（典型的生产者消费者问题），建立map（socket -> CELLclient的映射），建立`fd_set fdRead, fdWrite`,如何有客户端有改变，就会重新加入集合，如果没有改变就忽略这一步。客户端有数据过来就开始处理。

关闭客户端socket的时机：



## 4. 测试及改进

10K 客户端 4线程  每隔99ms发送100k数据包       服务端4线程          echo服务器   带宽可达80Mbps

开启的线程越大，处理包的能力会有所上升，关键是可提升客户端的发送能力。可以保持带宽平稳



## 5. 项目面试问题

1. 服务端程序中线程数目怎么确定的
2. 单线程和多线程性能差异
3. socket自带缓冲区大小  答： 如果数据片段不需要紧急传输的话，应用程序应该将他们拼接成更大的数据块，再调用Send。因为发送缓冲区很可能被复制到内核缓冲区，所以缓冲区不应该太大，通常比8K小一点点是很有效率的。
4. 为什么要封包？解决粘包问题
5. Linux下编译的方式：答：`g++ -std=c++11 -pthread server.cpp -o server`
6. gcc和g++的区别  答：`对于.c和.cpp文件，gcc分别当做c和cpp文件编译对于.c和.cpp文件，g++则统一当做cpp文件编译        使用g++编译文件时，**g++会自动链接标准库STL，而gcc不会自动链接STL      编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++   `
7. 应用层缓冲区大小为什么是400k   答：缓冲区大小是根据业务需求差异调整的
8. 就你的服务器而言，性能的最大阻碍是什么  答：select是最大阻碍的关键
9. windows下IP和虚拟机Linux IP地址（IP到IP的通信过程）
10. Linux下跟网络相关的命令 (ss、ping、netstat、lsof、ifconfig、route)
11. 客户端服务端编程的流程 (服务端：socket、bind、listen、accept、recv、send、close     客户端：socket、connect、send、recv、close)







## 其他知识点补充

1. UDP没有发送缓冲区，只有接收缓冲区
2. 





