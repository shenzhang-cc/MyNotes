## RB/B/B+引入的意义、特点及适用场景

### 二叉搜索树和AVL树

他们都善于搜索，但二叉搜索树容易失衡，及左右子树高度不一致，会加大时间复杂度。偏离logN时间复杂度。

为了维持理想的搜索时间复杂度，构造的办法就是把二叉搜索树改造成AVL树或者红黑树，**AVL树是严格维持平衡的。红黑树是黑平衡的**。但是维持平衡又需要额外的操作，这也加大了数据结构的时间复杂度，所以**红黑树可以看做是二叉搜索树和AVL树的一个折中**，可以尽量维持树的平衡，又不用话过多的时间来维持数据结构的性质。

**AVL树适合用于插入删除次数比较少，但查找多的情况。**





### 红黑树

1. 节点是红色或黑色
2. root是黑色
3. 所有的叶子节点都是黑色 (叶子是NIL节点)
4. 每个红色节点必须有两个黑色的子节点 (从每个叶子到根的所有路径上不能有两个连续的红色节点 )
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点





### B树

1. B树是一种多路搜索树，他的每个节点可以拥有多余两个孩子节点，M路的B树最多拥有M个孩子节点
2. 设计成多路是为了降低树的高度，进一步降低查找时间复杂度
3. 但是也不能设计成无限多路，这样会退化为有序数组
4. B树特别适用于二级（磁盘）存储器上的数据库维护。 原因：磁盘数据量大， 不能一次性加载到内存中。这时候使用B树，每次加载B树的一个节点，然后一步步加载（  **内存中，RB的效率比B高，涉及磁盘操作，B树更优** ）





### B+树

1. B+是在B Tree的基础上修改的，他的数据都在叶子节点，同时叶子节点之间还加了指针形成链表。
2. B+在数据库的索引中用的很多。原因：数据库select数据，不一定只选一条，有时候会选很多条，B树需要做局部中序遍历，可能要跨层访问。而B+ Tree由于所有数据都在叶子节点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就可以把所有数据取出来了。
3.  **为什么hash比B+ Tree更快，为啥MySQL 还用B+来存取索引？** 这和业务场景有关。如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。
4.  **为什么B+磁盘友好？** ①***磁盘读写代价更低***。树的非叶子结点里面没有数据，这样索引比较小，可以放在一个blcok（或者尽可能少的blcok）里面。避免了树+形结构不断的向下查找，然后磁盘不停的寻道，读数据。这样的设计，可以降低io的次数。②***查询效率更加稳定***。非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。③***遍历所有的数据更方便***。B+树只要遍历叶子节点就可以实现整棵树的遍历，而其他的树形结构 要中序遍历才可以访问所有的数据。

### RB、B and B+的区别

1. 红黑树的深度比较大，而B和B+树的深度则相对要小一些

2. B+树则将树都保存在叶子节点，同时通过链表的形式将他们连接在一起。

   

### B and B+的区别

1. B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
2. B+树中所有叶子节点都是通过指针连接在一起，而B树不会。
3. B树的优点：对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。
4. B+树的优点：非叶子节点上不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树 的高度，二是一个内部节点可以定位更多的叶子节点； 叶子节点之间通过指针来来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点之间不停地往返移动。

### Trie树

又名**单词查找树**，常用来操作字符串。它是**不同字符串的相同前缀只保存一份**。



### 布隆过滤器

**特点：**高效地插入和查询，占用空间更少，缺点是其返回的结果是概率性的。

























